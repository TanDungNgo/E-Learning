"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  compile: true
};
exports.compile = void 0;

var _dashify = _interopRequireDefault(require("dashify"));

var _indefiniteArticle = _interopRequireDefault(require("indefinite-article"));

var _index = require("./interfaces/index");

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});

var _index2 = require("./types/index");

Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index2[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index2[key];
    }
  });
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * @todo Explicitly referencing the barrel file seems to be necessary when enabling the
 * isolatedModules compiler option.
 */
const applyModifiers = (name, modifiers) => {
  if (modifiers === undefined) {
    return name;
  }

  return modifiers.reduce((modifiedName, modifier) => {
    if (modifier === 'capitalize') {
      const head = modifiedName.charAt(0).toUpperCase();
      const tail = modifiedName.slice(1);
      return `${head}${tail}`;
    }

    if (modifier === 'dashify') {
      return (0, _dashify.default)(modifiedName);
    }

    if (modifier === 'prependIndefiniteArticle') {
      return `${(0, _indefiniteArticle.default)(modifiedName)} ${modifiedName}`;
    }

    return modifiedName;
  }, name);
};

const buildRegex = variable => {
  const expression = variable.name + variable.modifiers.map(modifier => `\\.${modifier}\\(\\)`).join('');
  return new RegExp(`\\$\\{${expression}}`, 'g');
};

const preRenderString = (string, parameters) => {
  const expressionRegex = /\${([^.}]+)((\.[^(]+\(\))*)}/g;
  const variables = [];
  let expressionResult = expressionRegex.exec(string);

  while (expressionResult !== null) {
    const variable = {
      modifiers: [],
      name: expressionResult[1]
    };

    if (expressionResult[3] !== undefined) {
      const modifiersRegex = /\.[^(]+\(\)/g;
      let modifiersRegexResult = modifiersRegex.exec(expressionResult[2]);

      while (modifiersRegexResult !== null) {
        variable.modifiers.push(modifiersRegexResult[0].slice(1, -2));
        modifiersRegexResult = modifiersRegex.exec(expressionResult[2]);
      }
    }

    variables.push(variable);
    expressionResult = expressionRegex.exec(string);
  }

  const preRenderedParts = variables.reduce((parts, variable) => parts.map(part => {
    if (typeof part === 'string') {
      return part.split(buildRegex(variable)).reduce((prts, prt, index) => {
        if (index === 0) {
          return [prt];
        }

        if (variable.name in parameters) {
          return [...prts, applyModifiers(parameters[variable.name], variable.modifiers), prt];
        }

        return [...prts, prmtrs => applyModifiers(prmtrs[variable.name], variable.modifiers), prt];
      }, []);
    }

    return [part];
  }).reduce((prts, part) => [...prts, ...part], []), [string]);
  return missingParameters => preRenderedParts.reduce((renderedParts, preRenderedPart) => {
    if (typeof preRenderedPart === 'string') {
      return [...renderedParts, preRenderedPart];
    }

    return [...renderedParts, preRenderedPart(missingParameters)];
  }, []).join('');
};

const compile = (template, knownParameters = {}) => {
  const renderCode = template.code === undefined ? undefined : preRenderString(template.code, knownParameters);
  const renderMessage = template.message === undefined ? undefined : preRenderString(template.message, knownParameters);

  function render(causeOrMissingParameters = {}, optionalCause) {
    const hasNoOptionalCause = optionalCause === undefined && (causeOrMissingParameters instanceof Error || causeOrMissingParameters.code !== undefined && causeOrMissingParameters.code.slice(-9) === 'Exception');
    const {
      cause,
      missingParameters
    } = hasNoOptionalCause ? {
      cause: causeOrMissingParameters,
      missingParameters: {}
    } : {
      cause: optionalCause,
      missingParameters: causeOrMissingParameters
    };
    const err = renderMessage === undefined ? new Error() : new Error(renderMessage(missingParameters));

    if (cause !== null) {
      err.cause = cause;
    }

    if (renderCode !== undefined) {
      err.code = renderCode(missingParameters);
    }

    if (template.status !== undefined) {
      err.status = template.status;
    }

    return err;
  }

  return render;
};

exports.compile = compile;